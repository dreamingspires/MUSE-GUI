from functools import partial
from typing import Optional

import PySimpleGUI as sg

from .base import BaseWidget

"""
https://github.com/jason990420/PySimpleGUI-Solution/issues/122
"""


class EditableTable(BaseWidget):
    def __init__(self, rows, cols, key: Optional[str] = None, **kwargs):
        super().__init__(key)
        self.nrows = rows
        self.ncols = cols

        self._table_maker = partial(sg.Table, **kwargs)
        self._input_maker = partial(
            sg.Input,
            "",
            justification="right",
            disabled=True,
            disabled_readonly_background_color="#c3c3c3",
            pad=0,
            expand_x=True,
            expand_y=True,
        )
        self._frame_maker = partial(sg.Frame, "", border_width=1, pad=0, visible=False)

        self._row = 1
        self._col = 0
        self._editing = False
        self._focus = False
        self._disabled = True

    def commit(self):
        if self._editing:
            self.cell_text = self._input.get()

    @property
    def values(self):
        if self.nrows == 0 or self.ncols == 0:
            return [[]]
        self.commit()
        return [self.table_widget.item(r, "values") for r in range(1, self.nrows + 1)]

    @values.setter
    def values(self, _val):
        self.nrows = len(_val)
        self.ncols = len(_val[0])
        self._table.update(values=_val)
        if self.nrows == 0 or self.ncols == 0:
            return

        self._row = self._row % (self.nrows + 1)
        if self._row == 0:
            self._row = 1
        self._col = self._col % self.ncols
        self._update_cell_position()

    @property
    def table_widget(self):
        return self._table.Widget

    @property
    def frame_widget(self):
        return self._frame.Widget

    @property
    def row(self):
        return self._row

    @row.setter
    def row(self, val):
        if self._row == val:
            return

        # TODO Validation on num rows
        self._row = val % (self.nrows + 1)
        if self._row == 0:
            self._row = 1
        self._update_cell_position()

    @property
    def col(self):
        return self._col

    @col.setter
    def col(self, val):
        if self._col == val:
            return
        self._col = val % self.ncols
        self._update_cell_position()

    @property
    def cell_text(self):
        if self.nrows == 0 or self.ncols == 0:
            return ""
        return self.table_widget.item(self.row, "values")[self.col]

    @cell_text.setter
    def cell_text(self, val):

        # TODO Validation
        values = list(self.table_widget.item(self.row, "values"))
        values[self.col] = val
        self.table_widget.item(self.row, values=values)

    @property
    def editing(self):
        return self._editing

    @editing.setter
    def editing(self, val):
        self._editing = val and not self._disabled
        if not self._editing:
            self._table.set_focus()
            self._focus = True
            # TODO Hack - read and write again to remove selection
            self._input.update(
                value=self.cell_text,
                select=False,
                move_cursor_to="end",
                disabled=True,
            )
        else:
            self._input.set_focus()
            self._input.update(select=True, move_cursor_to="end", disabled=False)

    @property
    def disabled(self):
        return self._disabled

    @disabled.setter
    def disabled(self, val):
        if self._disabled == val:
            return
        self._disabled = val
        if self.editing:
            self.editing = False

    def _bind_resize_handler(self):
        self._table.bind("<B1-Motion>", "configure")
        self._table.bind("ButtonRelease-1", "configure-done")

    def _unbind_resize_handler(self):
        self._table.unbind("<B1-Motion>")
        self._table.unbind("ButtonRelease-1")

    def _update_cell_position(self):
        bbox = self.table_widget.bbox(self.row, self.col)
        if bbox:
            x, y, width, height = bbox
            self.frame_widget.place(
                x=x, y=y, anchor="nw", width=width - 2, height=height - 1
            )
        self._input.update(self.cell_text, select=True)

    def _handle_key_events(self, e):
        # Following events are generated by table,
        # so editing must be false
        if e == "up" or e == "down":
            self.row += -1 if e == "up" else 1
            return True
        if e == "left" or e == "right":
            self.col += -1 if e == "left" else 1
            return True

        # Following events will be generated by table or input
        if e == "tab" or e == "stab":
            if self.editing:
                self.cell_text = self._input.get()

            self.col += -1 if e == "stab" else 1

            # Lock focus to table on tab, shift tab
            if not self.editing and self._focus:
                self._table.set_focus()
            return True

        if e == "enter" or e == "senter":
            if e == "enter" and not self.disabled and not self.editing:
                self.editing = True
                return True

            if self.editing:
                self.cell_text = self._input.get()

            self.row += -1 if e == "senter" else 1

            if e == "senter" and not self.editing:
                self.editing = True

            return True

        return False

    def _handle_table_events(self, params):
        e, *rest = params
        print(e, rest)
        if e == "+CLICKED+":
            cell = row, col = rest[0]
            if row is None:
                return self._bind_resize_handler()
            if self.nrows == 0 or self.ncols == 0:
                # Clicking on an empty table
                return None
            if row is not None and col is not None:
                if self.editing:
                    # Currently editing a cell, copy value
                    self.cell_text = self._input.get()

                return self.edit_cell(row + 1, col)
        elif e == "configure":
            return self._update_cell_position()
        elif e == "configure-done":
            return self._unbind_resize_handler()
        elif e == "escape":
            self._focus = False
            return
        else:
            status = self._handle_key_events(e)
            if status:
                return
        print("Unhandled - ", e)

    def _handle_input_events(self, params):
        e, *_ = params
        print(e, _)
        if e == "escape":
            self.editing = False
            return

        status = self._handle_key_events(e)
        if status:
            self.editing = True

    def layout(self, prefix):
        if not self._layout:
            self.prefix = prefix
            self._table = self._table_maker(
                key=self._prefixf(),
            )
            self._input = self._input_maker(key=self._prefixf("input"))
            self._frame = self._frame_maker([[self._input]])
            self._layout = [
                [sg.Col([[self._table, self._frame]], expand_x=True, expand_y=True)]
            ]
        return self._layout

    def bind_handlers(self):

        # Block input element from getting focus with tab key
        self._frame.block_focus(True)
        self._input.block_focus(True)

        # Bind input element to keyboard events
        self._input.bind("<Escape>", "escape")
        self._input.bind("<Return>", "enter")
        self._input.bind("<Shift-Return>", "senter")
        self._input.bind("<Up>", "senter")
        self._input.bind("<Down>", "enter")
        self._input.bind("<Tab>", "tab")
        self._input.bind("<Shift-ISO_Left_Tab>", "stab")

        # Bind table to keyboard / resize events
        self._table.bind("<Configure>", "configure")
        self._table.bind("<Escape>", "escape")
        self._table.bind("<Return>", "enter")
        self._table.bind("<Shift-Return>", "senter")
        self._table.bind("<Up>", "up")
        self._table.bind("<Down>", "down")
        self._table.bind("<Left>", "left")
        self._table.bind("<Right>", "right")
        self._table.bind("<Tab>", "tab")
        self._table.bind("<Shift-ISO_Left_Tab>", "stab")

    def edit_cell(self, r, c):
        if r <= 0:
            return
        self.row = r
        self.col = c
        self.editing = True

    def __call__(self, window, event, values):
        e, *params = event
        if e == self.prefix:
            self._handle_table_events(params)
        elif e == self.prefix + ("input",):
            self._handle_input_events(params)


class FixedColumnTable(EditableTable):
    def __init__(self, rows, cols, nfixed, key: Optional[str] = None, **kwargs):

        super().__init__(rows, cols, key=key, **kwargs)
        self.nfixed = nfixed
        self._col = nfixed

    @property
    def col(self):
        return self._col

    @col.setter
    def col(self, val):
        if self._col == val:
            return
        self._col = val % self.ncols
        if self._col < self.nfixed:
            self._col = self.nfixed
        self._update_cell_position()

    def edit_cell(self, r, c):
        if r <= 0 or c < self.nfixed:
            return
        return super().edit_cell(r, c)
