from functools import partial
from typing import Optional
import PySimpleGUI as sg
from .base import BaseWidget
"""
https://github.com/jason990420/PySimpleGUI-Solution/issues/122
"""



class EditableTable(BaseWidget):
    def __init__(
            self,
            rows,
            cols,
            key: Optional[str] = None,
            **kwargs):
        super().__init__(key)
        self.nrows = rows
        self.ncols = cols

        self._table_maker = partial(
            sg.Table,
            **kwargs
        )
        self._input_maker = partial(
            sg.Input,
            '',
            justification='right',
            disabled=True,
            disabled_readonly_background_color='#c3c3c3',
            pad=0,
            expand_x=True, expand_y=True,
        )
        self._frame_maker = partial(
            sg.Frame,
            '',
            border_width=1,
            pad=0,
            visible=False
        )

        self._row = 1
        self._col = 0
        self._editing = False
        self._focus = False
        self._disabled = True

    def commit(self):
        if self._editing:
            self.cell_text = self._input.get()

    @property
    def values(self):
        if self.nrows == 0 or self.ncols == 0:
            return [[]]
        self.commit()
        return [
            self.table_widget.item(r, "values")
            for r in range(1, self.nrows + 1)
        ]

    @values.setter
    def values(self, _val):
        self.nrows = len(_val)
        self.ncols = len(_val[0])
        self._table.update(values=_val)
        if self.nrows == 0 or self.ncols == 0:
            return

        self._row = self._row % (self.nrows + 1)
        if self._row == 0:
            self._row = 1
        self._col = self._col % self.ncols
        self._update_cell_position()

    @property
    def table_widget(self):
        return self._table.Widget

    @property
    def frame_widget(self):
        return self._frame.Widget

    @property
    def row(self):
        return self._row

    @row.setter
    def row(self, val):
        if self._row == val:
            return

        # TODO Validation on num rows
        self._row = val % (self.nrows + 1)
        if self._row == 0:
            self._row = 1
        self._update_cell_position()

    @property
    def col(self):
        return self._col

    @col.setter
    def col(self, val):
        if self._col == val:
            return
        self._col = val % self.ncols
        self._update_cell_position()

    @property
    def cell_text(self):
        if self.nrows == 0 or self.ncols == 0:
            return ''
        return self.table_widget.item(self.row, "values")[self.col]

    @cell_text.setter
    def cell_text(self, val):

        # TODO Validation
        values = list(self.table_widget.item(self.row, 'values'))
        values[self.col] = val
        self.table_widget.item(self.row, values=values)

    @property
    def editing(self):
        return self._editing

    @editing.setter
    def editing(self, val):
        self._editing = val and not self._disabled
        if not self._editing:
            self._table.set_focus()
            self._focus = True
            # TODO Hack - read and write again to remove selection
            self._input.update(
                value=self.cell_text,
                select=False,
                move_cursor_to='end',
                disabled=True,
            )
        else:
            self._input.set_focus()
            self._input.update(
                select=True, move_cursor_to='end', disabled=False)
    @property
    def disabled(self):
        return self._disabled

    @disabled.setter
    def disabled(self, val):
        if self._disabled == val:
            return
        self._disabled = val
        if self.editing:
            self.editing = False

    def _bind_resize_handler(self):
        self._table.bind('<B1-Motion>', 'configure')
        self._table.bind('ButtonRelease-1', 'configure-done')

    def _unbind_resize_handler(self):
        self._table.unbind('<B1-Motion>')
        self._table.unbind('ButtonRelease-1')

    def _update_cell_position(self):
        bbox = self.table_widget.bbox(self.row, self.col)
        if bbox:
            x, y, width, height = bbox
            self.frame_widget.place(
                x=x, y=y, anchor="nw", width=width-2, height=height-1)
        self._input.update(self.cell_text, select=True)

    def _handle_key_events(self, e):
        # Following events are generated by table,
        # so editing must be false
        if e == 'up' or e == 'down':
            self.row += (-1 if e == 'up' else 1)
            return True
        if e == 'left' or e == 'right':
            self.col += (-1 if e == 'left' else 1)
            return True

        # Following events will be generated by table or input
        if e == 'tab' or e == 'stab':
            if self.editing:
                self.cell_text = self._input.get()

            self.col += (-1 if e == 'stab' else 1)

            # Lock focus to table on tab, shift tab
            if not self.editing and self._focus:
                self._table.set_focus()
            return True

        if e == 'enter' or e == 'senter':
            if e == 'enter' and not self.disabled and not self.editing:
                self.editing = True
                return True

            if self.editing:
                self.cell_text = self._input.get()

            self.row += (-1 if e == 'senter' else 1)

            if e == 'senter' and not self.editing:
                self.editing = True

            return True

        return False

    def _handle_table_events(self, params):
        e, *rest = params
        print(e, rest)
        if e == '+CLICKED+':
            cell = row, col = rest[0]
            if row is None:
                return self._bind_resize_handler()
            if self.nrows == 0 or self.ncols == 0:
                # Clicking on an empty table
                return None
            if row is not None and col is not None:
                if self.editing:
                    # Currently editing a cell, copy value
                    self.cell_text = self._input.get()

                return self.edit_cell(row + 1, col)
        elif e == 'configure':
            return self._update_cell_position()
        elif e == 'configure-done':
            return self._unbind_resize_handler()
        elif e == 'escape':
            self._focus = False
            return
        else:
            status = self._handle_key_events(e)
            if status:
                return
        print('Unhandled - ', e)

    def _handle_input_events(self, params):
        e, *_ = params
        print(e, _)
        if e == 'escape':
            self.editing = False
            return

        status = self._handle_key_events(e)
        if status:
            self.editing = True

    def layout(self, prefix):
        if not self._layout:
            self.prefix = prefix
            self._table = self._table_maker(
                key=self._prefixf(),
            )
            self._input = self._input_maker(
                key=self._prefixf('input')
            )
            self._frame = self._frame_maker([[self._input]])
            self._layout =  [[
                sg.Col([[
                    self._table,
                    self._frame
                ]],
                expand_x=True, expand_y=True)
            ]]
        return self._layout

    def bind_handlers(self):

        # Block input element from getting focus with tab key
        self._frame.block_focus(True)
        self._input.block_focus(True)

        # Bind input element to keyboard events
        self._input.bind('<Escape>', 'escape')
        self._input.bind('<Return>', 'enter')
        self._input.bind('<Shift-Return>', 'senter')
        self._input.bind('<Up>', 'senter')
        self._input.bind('<Down>', 'enter')
        self._input.bind('<Tab>', 'tab')
        self._input.bind('<Shift-ISO_Left_Tab>', 'stab')

        # Bind table to keyboard / resize events
        self._table.bind('<Configure>', 'configure')
        self._table.bind('<Escape>', 'escape')
        self._table.bind('<Return>', 'enter')
        self._table.bind('<Shift-Return>', 'senter')
        self._table.bind('<Up>', 'up')
        self._table.bind('<Down>', 'down')
        self._table.bind('<Left>', 'left')
        self._table.bind('<Right>', 'right')
        self._table.bind('<Tab>', 'tab')
        self._table.bind('<Shift-ISO_Left_Tab>', 'stab')

    def edit_cell(self, r, c):
        if r <= 0:
            return
        self.row = r
        self.col = c
        self.editing = True

    def __call__(self, window, event, values):
        e, *params = event
        if e == self.prefix:
            self._handle_table_events(params)
        elif e == self.prefix + ('input',):
            self._handle_input_events(params)


class FixedColumnTable(EditableTable):
    def __init__(
            self,
            rows,
            cols,
            nfixed,
            key: Optional[str] = None,
            **kwargs):

        super().__init__(rows, cols, key=key, **kwargs)
        self.nfixed = nfixed
        self._col = nfixed

    @property
    def col(self):
        return self._col

    @col.setter
    def col(self, val):
        if self._col == val:
            return
        self._col = val % self.ncols
        if self._col < self.nfixed:
            self._col = self.nfixed
        self._update_cell_position()

    def edit_cell(self, r, c):
        if r <= 0 or c < self.nfixed:
            return
        return super().edit_cell(r, c)
